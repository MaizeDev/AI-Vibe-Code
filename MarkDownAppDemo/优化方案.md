
# Models
### GitHubConfig.swift
```swift
import Foundation

struct GitHubConfig: Codable, Equatable {
    var owner: String
    var repo: String
    var token: String
    var branch: String
    
    // --- æ–°å¢: å­˜å‚¨è·¯å¾„ ---
    var path: String // e.g., "source/_posts"
    
    // ä¿®æ”¹é»˜è®¤å€¼ï¼Œé€‚é…ä½ çš„ Hexo
    static let empty = GitHubConfig(owner: "", repo: "", token: "", branch: "main", path: "source/_posts")
    
    var isValid: Bool {
        return !owner.isEmpty && !repo.isEmpty && !token.isEmpty
    }
}
```
### Post.swift
```swift
import Foundation

struct Post: Identifiable, Codable, Hashable {
    let id: UUID
    var title: String
    var content: String
    var createdAt: Date
    var updatedAt: Date
    var fileName: String
    var remoteSHA: String?
    
    var isPublished: Bool { remoteSHA != nil }
    
    init(id: UUID = UUID(), title: String, content: String, createdAt: Date = Date(), remoteSHA: String? = nil) {
        self.id = id
        self.title = title
        self.content = content
        self.createdAt = createdAt
        self.updatedAt = createdAt
        self.remoteSHA = remoteSHA
        // åˆå§‹åŒ–æ—¶è°ƒç”¨é™æ€æ–¹æ³•ç”Ÿæˆæ–‡ä»¶åï¼Œä¼ å…¥ id ä»¥é˜²é‡å¤
        self.fileName = Post.generateFileName(title: title, date: createdAt, id: id)
    }
    
    /// é™æ€è¾…åŠ©æ–¹æ³•ï¼šæ ¹æ®æ ‡é¢˜ã€æ—¥æœŸå’ŒIDç”Ÿæˆæ–‡ä»¶å
    static func generateFileName(title: String, date: Date, id: UUID) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        let dateStr = formatter.string(from: date)
        
        // æ ¸å¿ƒä¿®æ”¹ï¼šå¤„ç†ç©ºæ ‡é¢˜
        if title.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            // å¦‚æœæ ‡é¢˜ä¸ºç©ºï¼Œä½¿ç”¨ "untitled-UUIDå‰8ä½" ç¡®ä¿å”¯ä¸€æ€§
            let uniqueSuffix = id.uuidString.prefix(8).lowercased()
            return "\(dateStr)-untitled-\(uniqueSuffix).md"
        }
        
        // æ­£å¸¸æ ‡é¢˜çš„å¤„ç†é€»è¾‘
        let slug = title.lowercased()
            .components(separatedBy: .whitespacesAndNewlines)
            .joined(separator: "-")
            .filter { "abcdefghijklmnopqrstuvwxyz0123456789-".contains($0) }
        
        let finalSlug = slug.isEmpty ? "post" : slug
        return "\(dateStr)-\(finalSlug).md"
    }
}
```


# ViewModels
### AppState.swift
```swift
import Observation
import SwiftUI

@Observable
final class AppState {
    // MARK: - State Properties

    var posts: [Post] = []
    var selection: Post.ID?

    // ç›‘å¬é…ç½®å˜åŒ–ï¼Œè‡ªåŠ¨è°ƒç”¨ Service ä¿å­˜
    var gitHubConfig: GitHubConfig {
        didSet { settingsService.save(gitHubConfig) }
    }

    var isShowingSettings: Bool = false
    var isPublishing: Bool = false
    var saveStatus: String = "All Synced"

    // Error Handling
    var errorMessage: String?
    var showError: Bool = false

    // MARK: - Delete Logic State

    var showDeleteConfirmation: Bool = false
    var postToDelete: Post? // ä¸´æ—¶å­˜å‚¨å¾…åˆ é™¤çš„æ–‡ç« 

    // MARK: - Dependencies

    private let fileService: FileServiceProtocol
    private let gitHubService: GitHubServiceProtocol
    private let settingsService: SettingsServiceProtocol

    // Debounce Task
    private var saveTask: Task<Void, Error>?

    // MARK: - Initialization

    init(fileService: FileServiceProtocol = FileService(),
         gitHubService: GitHubServiceProtocol = GitHubService(),
         settingsService: SettingsServiceProtocol = SettingsService()) {
        self.fileService = fileService
        self.gitHubService = gitHubService
        self.settingsService = settingsService

        // ä» Service åŠ è½½é…ç½®
        gitHubConfig = settingsService.load()
    }

    // MARK: - Actions

    // 1. ç‚¹å‡»åˆ é™¤æŒ‰é’®æ—¶è°ƒç”¨ï¼ˆåªåšæ ‡è®°ï¼Œä¸æ‰§è¡Œï¼‰
    func requestDelete(post: Post) {
        postToDelete = post
        showDeleteConfirmation = true
    }

    // 2. ç”¨æˆ·åœ¨å¼¹çª—ç¡®è®¤åè°ƒç”¨ï¼ˆæ‰§è¡ŒçœŸå®åˆ é™¤ï¼‰
    func confirmDelete(alsoDeleteRemote: Bool) {
        guard let post = postToDelete else { return }

        // UI: ç«‹å³ä»åˆ—è¡¨ä¸­ç§»é™¤ (ä¹è§‚æ›´æ–°)
        if let index = posts.firstIndex(where: { $0.id == post.id }) {
            posts.remove(at: index)
        }
        if selection == post.id { selection = nil }

        // Async: æ‰§è¡Œç‰©ç†åˆ é™¤
        Task {
            // A. æœ¬åœ°å¿…åˆ 
            try? await fileService.delete(post: post)

            // B. è¿œç¨‹é€‰åˆ 
            if alsoDeleteRemote && post.isPublished {
                do {
                    // ç¡®ä¿é…ç½®æœ‰æ•ˆ
                    guard gitHubConfig.isValid else { return }
                    try await gitHubService.delete(post: post, config: gitHubConfig)
                    print("âœ… Remote file deleted")
                    await MainActor.run { self.saveStatus = "Deleted Locally & Remotely" }
                } catch {
                    print("âŒ Failed to delete remote file: \(error)")
                    await MainActor.run { self.displayError("Failed to delete remote file: \(error.localizedDescription)") }
                }
            } else {
                await MainActor.run { self.saveStatus = "Deleted Locally" }
            }
        }

        // é‡ç½®çŠ¶æ€
        postToDelete = nil
        showDeleteConfirmation = false
    }

    func loadPosts() async {
        do {
            let loaded = try await fileService.loadAllPosts()
            await MainActor.run { self.posts = loaded }
        } catch {
            displayError("Failed to load posts: \(error.localizedDescription)")
        }
    }

    func createPost() {
        let newPost = Post(title: "", content: "")
        posts.insert(newPost, at: 0)
        selection = newPost.id
        saveToDiskImmediately(post: newPost)
    }

    func deletePost(id: Post.ID) {
        guard let index = posts.firstIndex(where: { $0.id == id }) else { return }
        let post = posts[index]
        posts.remove(at: index)
        if selection == id { selection = nil }

        Task { try? await fileService.delete(post: post) }
    }

    func updateSelectedPost(title: String, content: String) {
        guard let id = selection,
              let index = posts.firstIndex(where: { $0.id == id }) else { return }

        // 1. Update Memory (UI)
        posts[index].title = title
        posts[index].content = content
        posts[index].updatedAt = Date()

        saveStatus = "Typing..."

        // 2. Debounce Save
        saveTask?.cancel()
        let currentPost = posts[index]

        saveTask = Task {
            try await Task.sleep(for: .milliseconds(800))
            if Task.isCancelled { return }
            await performDiskSync(postSnapshot: currentPost, index: index)
        }
    }

    func publishSelectedPost() {
        guard let id = selection,
              let index = posts.firstIndex(where: { $0.id == id }) else { return }

        let post = posts[index]
        guard gitHubConfig.isValid else {
            displayError("Please configure GitHub settings first.")
            isShowingSettings = true
            return
        }

        isPublishing = true

        Task {
            do {
                let newSHA = try await gitHubService.publish(post: post, config: gitHubConfig)
                await MainActor.run {
                    if posts.indices.contains(index) {
                        posts[index].remoteSHA = newSHA
                        posts[index].updatedAt = Date()
                        saveToDiskImmediately(post: posts[index])
                        saveStatus = "Published"
                        isPublishing = false
                    }
                }
            } catch {
                await MainActor.run {
                    isPublishing = false
                    displayError(error.localizedDescription)
                }
            }
        }
    }

    // MARK: - Private Helpers

    @MainActor
    private func performDiskSync(postSnapshot: Post, index: Int) async {
        guard posts.indices.contains(index), posts[index].id == postSnapshot.id else { return }

        saveStatus = "Saving..."
        let oldFileName = posts[index].fileName
        let newFileName = Post.generateFileName(title: postSnapshot.title, date: postSnapshot.createdAt, id: postSnapshot.id)

        do {
            if newFileName != oldFileName {
                try await fileService.rename(oldFileName: oldFileName, newFileName: newFileName)
                posts[index].fileName = newFileName
            }
            try await fileService.save(post: posts[index])
            saveStatus = "Saved"
        } catch {
            print("Disk Sync Error: \(error)")
            saveStatus = "Failed"
        }
    }

    private func saveToDiskImmediately(post: Post) {
        Task { try? await fileService.save(post: post) }
    }

    private func displayError(_ message: String) {
        errorMessage = message
        showError = true
    }
}
```

# Views
### ContentView.swift
```swift
import SwiftUI

struct ContentView: View {
    @State private var appState = AppState()

    var body: some View {
        HStack(spacing: 0) {
            NavigationSplitView {
                SidebarView(appState: appState)
                    .navigationSplitViewColumnWidth(min: 200, ideal: 250)
            } detail: {
                if let selectedId = appState.selection,
                   let post = appState.posts.first(where: { $0.id == selectedId }) {
                    EditorView(post: post, appState: appState)
                } else {
                    ContentUnavailableView("Select a Post", systemImage: "doc.text")
                }
            }

            if appState.isShowingSettings {
                SettingsPanel(appState: appState)
                    .transition(.move(edge: .trailing))
            }
        }
        // ä½¿ç”¨æŠ½ç¦»åçš„ Toolbar
        .toolbar {
            MainToolbar(appState: appState)
        }
        .onAppear {
            appState.isShowingSettings = true // æ–¹ä¾¿è°ƒè¯•ï¼Œå‘å¸ƒæ—¶å¯æ”¹ä¸º false
        }
        .task {
            await appState.loadPosts()
        }
        .alert("Error", isPresented: $appState.showError) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(appState.errorMessage ?? "Unknown error")
        }
        // --- æ–°å¢: åˆ é™¤ç¡®è®¤å¼¹çª— ---
        .confirmationDialog(
            "Delete Post",
            isPresented: $appState.showDeleteConfirmation,
            titleVisibility: .visible
        ) {
            // æŒ‰é’® 1: åŒæ—¶åˆ é™¤è¿œç¨‹ (ä»…å½“æ–‡ç« å·²å‘å¸ƒæ—¶æ˜¾ç¤º)
            if let post = appState.postToDelete, post.isPublished {
                Button("Delete Locally & Remotely", role: .destructive) {
                    appState.confirmDelete(alsoDeleteRemote: true)
                }
            }

            // æŒ‰é’® 2: ä»…åˆ é™¤æœ¬åœ°
            Button("Delete Locally Only", role: .destructive) {
                appState.confirmDelete(alsoDeleteRemote: false)
            }

            // æŒ‰é’® 3: å–æ¶ˆ
            Button("Cancel", role: .cancel) {
                appState.postToDelete = nil
            }
        } message: {
            if let post = appState.postToDelete {
                Text("Are you sure you want to delete '\(post.title)'?")
            }
        }
    }
}

#Preview {
    ContentView()
}

```

### EditorView.swift
```swift
import SwiftUI

struct EditorView: View {
    let post: Post
    var appState: AppState
    
    @State private var title: String
    @State private var content: String
    
    init(post: Post, appState: AppState) {
        self.post = post
        self.appState = appState
        _title = State(initialValue: post.title)
        _content = State(initialValue: post.content)
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // 1. å¤§æ ‡é¢˜è¾“å…¥æ¡†
            TextField("Enter Title", text: $title)
                .font(.system(size: 28, weight: .bold)) // æ¨¡ä»¿è®¾è®¡å›¾çš„å¤§å­—ä½“
                .textFieldStyle(.plain) // å»æ‰é»˜è®¤è¾¹æ¡†
                .padding(.horizontal)
                .padding(.top, 20)
                .onChange(of: title) { _, newValue in
                    appState.updateSelectedPost(title: newValue, content: content)
                }
            
            Divider()
                .padding(.horizontal)
            
            // 2. æ­£æ–‡ç¼–è¾‘åŒº
            TextEditor(text: $content)
                .font(.body) // åç»­å¯æ¢æˆç­‰å®½å­—ä½“ .monospaced()
                .scrollContentBackground(.hidden) // è®©èƒŒæ™¯é€æ˜ä»¥ä¾¿ç»Ÿä¸€è°ƒè‰²
                .padding(.horizontal)
                .padding(.bottom)
                .onChange(of: content) { _, newValue in
                    appState.updateSelectedPost(title: title, content: newValue)
                }
        }
        .background(Color(nsColor: .textBackgroundColor)) // ç¼–è¾‘åŒºç™½è‰²èƒŒæ™¯
        .onChange(of: post.id) { _, _ in
            title = post.title
            content = post.content
        }
    }
}

```

### MainToolbar.swift
```swift
import SwiftUI

struct MainToolbar: ToolbarContent {
    @Bindable var appState: AppState
    
    var body: some ToolbarContent {
        ToolbarItemGroup(placement: .primaryAction) {
            Button(action: { appState.createPost() }) {
                Label("New", systemImage: "plus")
            }
            
            if appState.isPublishing {
                ProgressView().controlSize(.small).padding(.horizontal, 8)
            } else {
                Text(appState.saveStatus)
                    .font(.caption)
                    .foregroundStyle(.secondary)
                    .padding(.horizontal, 8)
            }
            
            Button(action: { appState.publishSelectedPost() }) {
                Label("Publish", systemImage: "paperplane")
            }
            .disabled(appState.selection == nil || appState.isPublishing)
            .keyboardShortcut("p", modifiers: .command)
            
            Button(action: {
                if let id = appState.selection,
                   let post = appState.posts.first(where: { $0.id == id }) {
                    // ä¿®æ”¹è¿™é‡Œï¼šè°ƒç”¨è¯·æ±‚åˆ é™¤
                    appState.requestDelete(post: post)
                }
            }) {
                Label("Delete", systemImage: "trash")
            }
            .disabled(appState.selection == nil)
        }
        
        ToolbarItem(placement: .automatic) {
            Button(action: {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                    appState.isShowingSettings.toggle()
                }
            }) {
                Label("Settings", systemImage: "gearshape")
            }
        }
    }
}

```

### SettingsPanel.swift
```swift
import SwiftUI

struct SettingsPanel: View {
    @Bindable var appState: AppState

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                // Header
                Text("Settings")
                    .font(.headline)
                    .padding(.bottom, 8)

                // Section 1: GitHub Account
                VStack(alignment: .leading, spacing: 8) {
                    Text("GitHub Account")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)

                    // --- ä¼˜åŒ–: ä½¿ç”¨ SecureField å¹¶å¢åŠ è¯´æ˜ ---
                    SecureField("Personal Access Token (repo scope)", text: $appState.gitHubConfig.token)
                        .textFieldStyle(.roundedBorder)

                    Text("Required scope: repo")
                        .font(.caption2)
                        .foregroundStyle(.tertiary)

                    // --- æš‚æ—¶æ³¨é‡Šæ‰ Check Tokenï¼ŒStep 3 å®ç° ---
                    /*
                     Button(action: { }) {
                         Label("Check Token", systemImage: "person.badge.key")
                             .frame(maxWidth: .infinity)
                     }
                     .controlSize(.large)
                     */
                }

                Divider()

                // Section 2: Repository
                VStack(alignment: .leading, spacing: 8) {
                    Text("Repository")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)

                    Text("Owner (Username)")
                        .font(.caption)
                    TextField("e.g. apple", text: $appState.gitHubConfig.owner)
                        .textFieldStyle(.roundedBorder)

                    Text("Repo Name")
                        .font(.caption)
                    TextField("e.g. swift", text: $appState.gitHubConfig.repo)
                        .textFieldStyle(.roundedBorder)

                    // --- æ–°å¢ï¼šFolder Path ---
                    Text("Folder Path")
                        .font(.caption)
                    TextField("e.g. source/_posts", text: $appState.gitHubConfig.path)
                        .textFieldStyle(.roundedBorder)
                    Text("Leave empty for root")
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                }

                Divider()

                // Section 3: Blog URL (Optional for MVP)
                VStack(alignment: .leading, spacing: 8) {
                    Text("Blog URL")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)

                    Text("Site Address:")
                        .font(.caption)
                    TextField("https://myblog.github.io", text: .constant("")) // æš‚æ—¶å ä½
                        .textFieldStyle(.roundedBorder)
                        .disabled(true)
                }

                Spacer()
            }
            .padding()
        }
        .frame(width: 260) // å›ºå®šå®½åº¦ï¼Œç¬¦åˆ Inspector è®¾è®¡
        .background(Color(nsColor: .controlBackgroundColor)) // ç•¥ç°çš„èƒŒæ™¯
        .overlay(
            Rectangle()
                .fill(Color(nsColor: .separatorColor))
                .frame(width: 1), // 1åƒç´ å®½çš„çº¿
            alignment: .leading // è´´åœ¨å·¦è¾¹ç¼˜
        )
    }
}

```

### SidebarView.swift
```swift
import SwiftUI

struct SidebarView: View {
    @Bindable var appState: AppState

    var body: some View {
        List(selection: $appState.selection) {
            Section(header: Text("Posts")) {
                ForEach(appState.posts) { post in
                    NavigationLink(value: post.id) {
                        HStack {
                            // ä¿®æ”¹æ˜¾ç¤ºé€»è¾‘
                            if post.title.isEmpty {
                                Text("Untitled")
                                    .font(.body)
                                    .foregroundStyle(.secondary) // ç°è‰²æ˜¾ç¤º
                                    .italic()
                            } else {
                                Text(post.title)
                                    .font(.body)
                                    .lineLimit(1)
                            }

                            Spacer()

                            Text(post.createdAt.formatted(date: .abbreviated, time: .omitted))
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                        .padding(.vertical, 2)
                    }
                }
            }
        }
        .listStyle(.sidebar) // macOS æ ‡å‡†ä¾§è¾¹æ æ ·å¼
        // ç§»é™¤é»˜è®¤çš„ navigationTitleï¼Œå› ä¸ºè®¾è®¡å›¾æ²¡æœ‰å¤§æ ‡é¢˜
    }
}
```

# Services	
### FileService.swift
```swift
import Foundation

final class FileService: FileServiceProtocol {
    
    private let fileManager = FileManager.default
    
    // ... (ä¹‹å‰çš„ postsDirectoryURL å’Œ init ä¿æŒä¸å˜) ...
    private var postsDirectoryURL: URL {
        let documents = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!
        return documents.appending(path: "PodcastBlogStudio/posts")
    }
    
    init() {
        // å»ºè®®ä¿ç•™æ‰“å°è·¯å¾„ï¼Œæ–¹ä¾¿åç»­è°ƒè¯•
        print("ğŸ“‚ Local Storage Path: \(postsDirectoryURL.path(percentEncoded: false))")
        try? createDirectoryIfNeeded()
    }
    
    private func createDirectoryIfNeeded() throws {
        if !fileManager.fileExists(atPath: postsDirectoryURL.path(percentEncoded: false)) {
            try fileManager.createDirectory(at: postsDirectoryURL, withIntermediateDirectories: true)
        }
    }

    // ... (save å’Œ loadAllPosts ä¿æŒä¸å˜) ...
    
    func save(post: Post) async throws {
        try createDirectoryIfNeeded()
        let fileContent = MarkdownParser.generateContent(for: post)
        let fileURL = postsDirectoryURL.appending(path: post.fileName)
        try fileContent.write(to: fileURL, atomically: true, encoding: .utf8)
        // print("ğŸ’¾ Saved: \(post.fileName)") // æ—¥å¿—å¤ªå¤šå¯ä»¥æ³¨é‡Šæ‰
    }
    
    func loadAllPosts() async throws -> [Post] {
        // ... (ä¿æŒä¹‹å‰çš„ä»£ç ä¸å˜) ...
        // ä¸ºäº†èŠ‚çœç¯‡å¹…ï¼Œè¿™é‡Œçœç•¥ loadAllPosts çš„å…·ä½“å®ç°ï¼Œè¯·ä¿æŒåŸæ ·
        // åªéœ€è¦ç¡®ä¿ delete æ–¹æ³•ä¹Ÿåœ¨å³å¯
        try createDirectoryIfNeeded()
        let resourceKeys: [URLResourceKey] = [.creationDateKey, .contentModificationDateKey]
        let fileURLs = try fileManager.contentsOfDirectory(at: postsDirectoryURL, includingPropertiesForKeys: resourceKeys)
            .filter { $0.pathExtension == "md" }
        
        var loadedPosts: [Post] = []
        for url in fileURLs {
            do {
                let content = try String(contentsOf: url, encoding: .utf8)
                let parsed = MarkdownParser.parse(fileContent: content)
                let values = try url.resourceValues(forKeys: Set(resourceKeys))
                let updatedAt = values.contentModificationDate ?? Date()
                
                var post = Post(
                    id: UUID(),
                    title: parsed.title,
                    content: parsed.body,
                    createdAt: parsed.date,
                    remoteSHA: parsed.sha
                )
                // å…³é”®ï¼šåŠ è½½æ—¶å¿…é¡»ç”¨å®é™…æ–‡ä»¶åè¦†ç›–ï¼Œç¡®ä¿åŒæ­¥
                post.fileName = url.lastPathComponent
                post.updatedAt = updatedAt
                loadedPosts.append(post)
            } catch { print("âŒ Load error: \(error)") }
        }
        return loadedPosts.sorted { $0.createdAt > $1.createdAt }
    }
    
    func delete(post: Post) async throws {
        let fileURL = postsDirectoryURL.appending(path: post.fileName)
        if fileManager.fileExists(atPath: fileURL.path(percentEncoded: false)) {
            try fileManager.removeItem(at: fileURL)
            print("ğŸ—‘ Deleted: \(post.fileName)")
        }
    }
    
    // MARK: - Rename
        
        /// é‡å‘½åæ–‡ä»¶
        /// - Parameters:
        ///   - oldFileName: æ—§æ–‡ä»¶å (e.g. "untitled.md")
        ///   - newFileName: æ–°æ–‡ä»¶å (e.g. "hello.md")
        func rename(oldFileName: String, newFileName: String) async throws {
            let oldURL = postsDirectoryURL.appending(path: oldFileName)
            let newURL = postsDirectoryURL.appending(path: newFileName)
            
            // 1. åŸºæœ¬æ£€æŸ¥
            if oldURL == newURL { return }
            
            // 2. ç¡®ä¿åŸæ–‡ä»¶å­˜åœ¨æ‰ç§»åŠ¨
            if fileManager.fileExists(atPath: oldURL.path(percentEncoded: false)) {
                
                // å®‰å…¨æªæ–½ï¼šå¦‚æœç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨ï¼ˆæå°‘æƒ…å†µï¼‰ï¼Œå…ˆåˆ é™¤ç›®æ ‡ï¼Œé˜²æ­¢æŠ¥é”™
                if fileManager.fileExists(atPath: newURL.path(percentEncoded: false)) {
                    try fileManager.removeItem(at: newURL)
                }
                
                try fileManager.moveItem(at: oldURL, to: newURL)
                print("âœï¸ Renamed on Disk: \(oldFileName) -> \(newFileName)")
            } else {
                // å¦‚æœåŸæ–‡ä»¶æ‰¾ä¸åˆ°ï¼ˆå¯èƒ½æ˜¯è¿˜æ²¡ä¿å­˜è¿‡ï¼‰ï¼Œåˆ™ä¸åšç§»åŠ¨ï¼Œäº¤ç”±åç»­çš„ save() å»åˆ›å»ºæ–°æ–‡ä»¶
                print("âš ï¸ Rename source not found: \(oldFileName). Will create new file via save().")
            }
        }
}
```

### FileServiceProtocol.swift
```swift

import Foundation

// MARK: - File Service Protocol
protocol FileServiceProtocol {
    func save(post: Post) async throws
    func loadAllPosts() async throws -> [Post]
    func delete(post: Post) async throws
    
    // ä¹‹å‰æŠ¥é”™æ˜¯å› ä¸ºç¼ºäº†ä¸‹é¢è¿™ä¸€è¡Œå£°æ˜ï¼š
    func rename(oldFileName: String, newFileName: String) async throws
}

// MARK: - GitHub Service Protocol
protocol GitHubServiceProtocol {
    func publish(post: Post, config: GitHubConfig) async throws -> String
    func delete(post: Post, config: GitHubConfig) async throws
}

// MARK: - Settings Service Protocol
// ä¹‹å‰æŠ¥é”™æ˜¯å› ä¸ºç¼ºäº†æ•´ä¸ªåè®®å®šä¹‰ï¼š
protocol SettingsServiceProtocol {
    func load() -> GitHubConfig
    func save(_ config: GitHubConfig)
}
```

### GitHubError.swift
```swift

import Foundation

enum GitHubError: Error, LocalizedError {
    case invalidConfig
    case invalidURL
    case apiError(String)
    case noData
    case decodingError
    case missingSHA // åˆ é™¤æ—¶å¿…é¡»æœ‰ SHA
    
    var errorDescription: String? {
        switch self {
        case .invalidConfig: return "Please check your GitHub settings (Token/Repo)."
        case .invalidURL: return "Invalid URL construction."
        case .apiError(let msg): return "GitHub API Error: \(msg)"
        case .noData: return "No data received from GitHub."
        case .decodingError: return "Failed to decode response."
        case .missingSHA: return "Cannot delete file without SHA. Is it published?"
        }
    }
}
```

### GitHubService..swift
```swift
//
//  GitHubService.swift
//  PodcastBlogStudio
//
//  Created by wheat on 1/29/26.
//

import Foundation

// MARK: - Service Implementation
final class GitHubService: GitHubServiceProtocol {
    
    // MARK: - Response Models
    struct GitHubFileResponse: Decodable {
        let content: ContentInfo?
        struct ContentInfo: Decodable { let sha: String }
    }
    
    // MARK: - Request Models
    struct PutFileRequest: Encodable {
        let message: String
        let content: String
        let sha: String?
        let branch: String?
    }
    
    struct DeleteFileRequest: Encodable {
        let message: String
        let sha: String
        let branch: String?
    }
    
    // MARK: - Publish (Create or Update)
    
    func publish(post: Post, config: GitHubConfig) async throws -> String {
        guard config.isValid else { throw GitHubError.invalidConfig }
        
        // 1. è·å– URL (å¤ç”¨é€»è¾‘)
        let url = try buildURL(for: post, config: config)
        
        // 2. å‡†å¤‡å†…å®¹
        let markdownString = MarkdownParser.generateContent(for: post)
        guard let contentData = markdownString.data(using: .utf8) else { throw GitHubError.decodingError }
        
        let body = PutFileRequest(
            message: "Publish: \(post.title)",
            content: contentData.base64EncodedString(),
            sha: post.remoteSHA,
            branch: config.branch.isEmpty ? "main" : config.branch
        )
        
        // 3. æ„é€ è¯·æ±‚
        var request = URLRequest(url: url)
        request.httpMethod = "PUT"
        request.setValue("token \(config.token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.httpBody = try JSONEncoder().encode(body)
        
        print("ğŸš€ Publishing to: \(url.absoluteString)")
        
        // 4. å‘é€å¹¶å¤„ç†
        let (data, _) = try await send(request: request)
        
        // 5. è§£ææ–° SHA
        let decoded = try JSONDecoder().decode(GitHubFileResponse.self, from: data)
        guard let newSHA = decoded.content?.sha else {
            throw GitHubError.decodingError
        }
        
        return newSHA
    }
    
    // MARK: - Delete (Remove File)
    
    func delete(post: Post, config: GitHubConfig) async throws {
        guard config.isValid else { throw GitHubError.invalidConfig }
        // åˆ é™¤æ–‡ä»¶å¿…é¡»æä¾› shaï¼Œå¦åˆ™ GitHub ä¸çŸ¥é“ä½ åˆ çš„æ˜¯å“ªä¸ªç‰ˆæœ¬
        guard let sha = post.remoteSHA else { throw GitHubError.missingSHA }
        
        // 1. è·å– URL
        let url = try buildURL(for: post, config: config)
        
        // 2. æ„é€ è¯·æ±‚ä½“ (GitHub åˆ é™¤ API éœ€è¦ä¼  body)
        let body = DeleteFileRequest(
            message: "Delete: \(post.title)",
            sha: sha,
            branch: config.branch.isEmpty ? "main" : config.branch
        )
        
        // 3. æ„é€ è¯·æ±‚
        var request = URLRequest(url: url)
        request.httpMethod = "DELETE"
        request.setValue("token \(config.token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.httpBody = try JSONEncoder().encode(body)
        
        print("ğŸ—‘ Deleting remote file: \(url.absoluteString)")
        
        // 4. å‘é€ (ä¸éœ€è¦è¿”å›å€¼ï¼Œåªè¦ä¸æŠ¥é”™å°±æ˜¯æˆåŠŸ)
        _ = try await send(request: request)
    }
    
    // MARK: - Private Helpers
    
    /// ç»Ÿä¸€æ„å»ºæ–‡ä»¶ API çš„ URL
    private func buildURL(for post: Post, config: GitHubConfig) throws -> URL {
        // å¤„ç†è·¯å¾„ï¼šå»æ‰é¦–å°¾çš„ /
        let folderPath = config.path.trimmingCharacters(in: CharacterSet(charactersIn: "/"))
        // å¦‚æœ path ä¸ºç©ºåˆ™åœ¨æ ¹ç›®å½•ï¼Œå¦åˆ™æ‹¼æ¥
        let fullFilePath = folderPath.isEmpty ? post.fileName : "\(folderPath)/\(post.fileName)"
        
        // è¿›è¡Œ URL ç¼–ç  (è§£å†³ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦é—®é¢˜)
        guard let encodedPath = fullFilePath.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) else {
            throw GitHubError.invalidURL
        }
        
        let urlString = "https://api.github.com/repos/\(config.owner)/\(config.repo)/contents/\(encodedPath)"
        
        guard let url = URL(string: urlString) else {
            throw GitHubError.invalidURL
        }
        
        return url
    }
    
    /// ç»Ÿä¸€å‘é€è¯·æ±‚å¹¶å¤„ç† HTTP çŠ¶æ€ç 
    private func send(request: URLRequest) async throws -> (Data, URLResponse) {
        let (data, response) = try await URLSession.shared.data(for: request)
        
        if let httpResponse = response as? HTTPURLResponse {
            // 200...299 éƒ½æ˜¯æˆåŠŸ (PUT è¿”å› 200/201, DELETE è¿”å› 200/204)
            if !(200...299).contains(httpResponse.statusCode) {
                let errorMsg = String(data: data, encoding: .utf8) ?? "Unknown Error"
                print("âŒ API Error [\(httpResponse.statusCode)]: \(errorMsg)")
                
                switch httpResponse.statusCode {
                case 401: throw GitHubError.apiError("Unauthorized. Check Token.")
                case 404: throw GitHubError.apiError("File or Repo not found.")
                case 409: throw GitHubError.apiError("Conflict. Sync required.")
                case 422: throw GitHubError.apiError("Validation Failed.")
                default:  throw GitHubError.apiError("Status \(httpResponse.statusCode)")
                }
            }
        }
        return (data, response)
    }
}
```

### SettingsService.swift
```swift
import Foundation

final class SettingsService: SettingsServiceProtocol {
    private let key = "GitHubConfig"
    
    func save(_ config: GitHubConfig) {
        if let encoded = try? JSONEncoder().encode(config) {
            UserDefaults.standard.set(encoded, forKey: key)
        }
    }
    
    func load() -> GitHubConfig {
        if let data = UserDefaults.standard.data(forKey: key),
           let decoded = try? JSONDecoder().decode(GitHubConfig.self, from: data) {
            return decoded
        }
        return GitHubConfig.empty
    }
}
```


# Utils	
### MarkdownParser.swift
```swift
import Foundation

struct MarkdownParser {
    
    // MARK: - Writer
    
    static func generateContent(for post: Post) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        let dateStr = formatter.string(from: post.createdAt)
        
        var yamlContent = "title: \(post.title)\ndate: \(dateStr)"
        
        // å¦‚æœæœ‰ SHAï¼Œä¹Ÿå­˜å…¥ Frontmatter (ä½œä¸ºéšè—å…ƒæ•°æ®)
        if let sha = post.remoteSHA {
            yamlContent += "\nsha: \(sha)"
        }
        
        // æ„é€ æ ‡å‡†çš„ Frontmatter
        let frontmatter = """
        ---
        \(yamlContent)
        ---
        
        """
        
        return frontmatter + post.content
    }
    
    // MARK: - Reader
    
    /// è§£ææ–‡ä»¶å†…å®¹
    static func parse(fileContent: String) -> (title: String, date: Date, sha: String?, body: String) {
        var title = "Untitled"
        var date = Date()
        var sha: String? = nil
        var body = fileContent
        
        // æ­£åˆ™åŒ¹é… YAML Frontmatter
        // åŒ¹é…è§„åˆ™ï¼šä»¥ --- å¼€å¤´ï¼Œä¸­é—´éè´ªå©ªåŒ¹é…ä»»æ„å­—ç¬¦ï¼Œä»¥ --- ç»“å°¾
        let pattern = #"^---\n([\s\S]*?)\n---\n"#
        
        if let regex = try? NSRegularExpression(pattern: pattern, options: .anchorsMatchLines),
           let match = regex.firstMatch(in: fileContent, range: NSRange(fileContent.startIndex..., in: fileContent)) {
            
            // 1. æå–å…ƒæ•°æ®åŒº
            if let range = Range(match.range(at: 1), in: fileContent) {
                let metadataStr = String(fileContent[range])
                let parsedMeta = parseYaml(metadataStr)
                
                if let t = parsedMeta["title"] { title = t }
                if let dStr = parsedMeta["date"], let d = parseDate(dStr) { date = d }
                if let s = parsedMeta["sha"] { sha = s }
            }
            
            // 2. æå–æ­£æ–‡
            if let range = Range(match.range, in: fileContent) {
                body = String(fileContent[range.upperBound...])
            }
        }
        
        return (title, date, sha, body)
    }
    
    // MARK: - Helpers
    
    private static func parseYaml(_ content: String) -> [String: String] {
        var result: [String: String] = [:]
        content.enumerateLines { line, _ in
            let parts = line.split(separator: ":", maxSplits: 1).map { $0.trimmingCharacters(in: .whitespaces) }
            if parts.count == 2 {
                result[parts[0]] = parts[1]
            }
        }
        return result
    }
    
    private static func parseDate(_ dateStr: String) -> Date? {
        let formatter = DateFormatter()
        // å°è¯•å¤šç§æ—¥æœŸæ ¼å¼ï¼Œå…¼å®¹ Hexo å¸¸è§çš„æ ¼å¼
        let formats = ["yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM-dd"]
        
        for format in formats {
            formatter.dateFormat = format
            if let date = formatter.date(from: dateStr) {
                return date
            }
        }
        return nil
    }
}
```

# App
### PodcastBlogStudioApp.swift
```swift
import SwiftUI

@main
struct PodcastBlogStudioApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```